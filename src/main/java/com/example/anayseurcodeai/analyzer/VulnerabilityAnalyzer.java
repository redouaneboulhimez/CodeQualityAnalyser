package com.example.anayseurcodeai.analyzer;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Analyzer for security vulnerabilities in code.
 */
public class VulnerabilityAnalyzer implements CodeAnalyzer {
    
    // List of potentially dangerous methods
    private static final List<String> DANGEROUS_METHODS = Arrays.asList(
        "exec", "execute", "eval", "executeQuery", "executeUpdate", "createStatement",
        "prepareStatement", "prepareCall", "loadClass", "forName", "newInstance"
    );
    
    // List of potentially insecure methods
    private static final List<String> INSECURE_METHODS = Arrays.asList(
        "getParameter", "getHeader", "getQueryString", "getCookie", "getInputStream",
        "getReader", "getRequestURI", "getRequestURL", "getServerName", "getRemoteAddr"
    );
    
    @Override
    public List<CodeIssue> analyzeFile(CodeParser.ParsedFile parsedFile) {
        List<CodeIssue> issues = new ArrayList<>();
        CompilationUnit cu = parsedFile.getCompilationUnit();
        String fileName = parsedFile.getFile().getName();
        
        // Check for SQL injection vulnerabilities
        checkSqlInjection(cu, fileName, issues);
        
        // Check for command injection vulnerabilities
        checkCommandInjection(cu, fileName, issues);
        
        // Check for insecure random number generation
        checkInsecureRandom(cu, fileName, issues);
        
        // Check for hardcoded credentials
        checkHardcodedCredentials(cu, fileName, issues);
        
        return issues;
    }
    
    @Override
    public AnalyzerType getType() {
        return AnalyzerType.VULNERABILITY;
    }
    
    /**
     * Check for potential SQL injection vulnerabilities.
     */
    private void checkSqlInjection(CompilationUnit cu, String fileName, List<CodeIssue> issues) {
        cu.accept(new VoidVisitorAdapter<Void>() {
            @Override
            public void visit(MethodCallExpr n, Void arg) {
                super.visit(n, arg);
                
                // Check for SQL execution methods with string concatenation
                if (Arrays.asList("executeQuery", "executeUpdate", "execute").contains(n.getNameAsString())) {
                    String argument = n.getArguments().isEmpty() ? "" : n.getArguments().get(0).toString();
                    if (argument.contains("+") || argument.contains("concat")) {
                        issues.add(new CodeIssue(
                            fileName,
                            n.getBegin().get().line,
                            "Potential SQL injection vulnerability: " + n.toString(),
                            AnalyzerType.VULNERABILITY,
                            CodeIssue.Severity.CRITICAL
                        ));
                    }
                }
            }
        }, null);
    }
    
    /**
     * Check for potential command injection vulnerabilities.
     */
    private void checkCommandInjection(CompilationUnit cu, String fileName, List<CodeIssue> issues) {
        cu.accept(new VoidVisitorAdapter<Void>() {
            @Override
            public void visit(MethodCallExpr n, Void arg) {
                super.visit(n, arg);
                
                // Check for Runtime.exec or ProcessBuilder with user input
                if (n.getNameAsString().equals("exec") || 
                    (n.getScope().isPresent() && n.getScope().get().toString().contains("Runtime"))) {
                    issues.add(new CodeIssue(
                        fileName,
                        n.getBegin().get().line,
                        "Potential command injection vulnerability: " + n.toString(),
                        AnalyzerType.VULNERABILITY,
                        CodeIssue.Severity.CRITICAL
                    ));
                }
            }
        }, null);
    }
    
    /**
     * Check for insecure random number generation.
     */
    private void checkInsecureRandom(CompilationUnit cu, String fileName, List<CodeIssue> issues) {
        cu.accept(new VoidVisitorAdapter<Void>() {
            @Override
            public void visit(MethodCallExpr n, Void arg) {
                super.visit(n, arg);
                
                // Check for java.util.Random instead of SecureRandom
                if (n.getNameAsString().equals("Random") && 
                    n.getScope().isPresent() && 
                    n.getScope().get().toString().equals("new")) {
                    issues.add(new CodeIssue(
                        fileName,
                        n.getBegin().get().line,
                        "Insecure random number generation. Consider using java.security.SecureRandom instead.",
                        AnalyzerType.VULNERABILITY,
                        CodeIssue.Severity.MEDIUM
                    ));
                }
            }
        }, null);
    }
    
    /**
     * Check for hardcoded credentials.
     */
    private void checkHardcodedCredentials(CompilationUnit cu, String fileName, List<CodeIssue> issues) {
        // This is a simplified example. A real implementation would be more sophisticated.
        cu.findAll(MethodDeclaration.class).forEach(method -> {
            if (method.getBody().isPresent()) {
                String body = method.getBody().get().toString().toLowerCase();
                if ((body.contains("password") || body.contains("passwd") || body.contains("pwd") || 
                     body.contains("secret") || body.contains("credential")) && 
                    (body.contains("\"") || body.contains("'"))) {
                    issues.add(new CodeIssue(
                        fileName,
                        method.getBegin().get().line,
                        "Method may contain hardcoded credentials: " + method.getNameAsString(),
                        AnalyzerType.VULNERABILITY,
                        CodeIssue.Severity.HIGH
                    ));
                }
            }
        });
    }
}